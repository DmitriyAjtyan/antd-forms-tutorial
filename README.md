# antd-forms-tutorial

Это проект-обучалка по использованию antd форм.

Чтобы нормально работать с проектом на вашем рабочем компе должны быть установлены:

1. git ^2.36.1
2. node.js ^18.20.2
3. npm ^10.5.0

Если всё вышеперечисленное у вас уже установлено, то сделайте fork данного репозитория или работайте с ним же, но создайте себе отдельную ветку из ветки main с названием, включающим ваш логин / фио. После клонирования репозитория на свой комп установите библиотеки при помощи команды:

npm install

После установки библиотек проверьте, что все скрипты из package.json корректно работают. Для этого выполните следующие команды:

1. npm run dev
2. npm run build
3. npm run lint
4. npm run preview

Если всё работает хорошо, то можно приступать к выполнению заданий.

Перед тем как вы начнёте писать код мы введём несколько ограничений на то, как вы будете его писать:

1. Нарушать правила хуков React строго запрещено. Указывайте в хуках все необходимые зависимости / используйте их только там, где их можно использовать.
2. Использование хуков useState, useEffect, useLayoutEffect, useRef, useId запрещено. Конкретно для этих задач использование этих хуков скорее означает, что вы делаете что-то неправильно. Единственное место, в котором можно использовать useEffect и useState - кастомные хуки, иммитирующие работу с backend'ом и кастомные хуки для обработкк зависимостей в форме (об этих ситуациях я ещё раз упомяну, когда настанет время).
3. Установка каких-либо дополнительных библиотек так же запрещена. Для этих задач никаких дополнительных библиотек вам не понадобится. Того, что есть в antd и @ant-design/icons, хватит с головой.
4. Компоненты храните в src/components, константы в src/constants, хуки в src/hooks, утилиты в src/utils, типы в src/types. index файлы уже созданы. Так же в проекте есть алиасы @components, @constants, @hooks, @utils, @types для удобства импортов.
5. Для каждого задания делайте отдельный коммит.

"макеты" для форм лежат в корне проекта в папке layouts

<br>
Задание 1.
<br>
Нужно сделать форму регистрации пользователя в простейшем виде. В форме дожны присутствовать следующие поля:
<br>
<br>

1. Инпут для ввода логина
2. Инпут для ввода пароля
3. Инпут для повторного ввода пароля
4. Инпут для ввода email
5. Инпут для ввода номера телефона
6. Селект для выбора страны
7. Кнопка с текстом "Регстрация"
8. Кнопка с текстом "Очистить"

На данный момент не нужно добавлять никакой логики для валидации / отправки / очистки формы. Просто сверстайте её по макету 1 из layouts. В значения для селекта захардкодьте и вынесите в @constants.
<br>
Подсказка: вам понадобятся компоненты Form, Form.Item, Input, Select, Button, Row, Col.

<br>
<br>

Задание 2.
<br>
Теперь добавим плейсхолдеры для каждого поля формы. Что именно написать в плейсхолдере - не имеет особого значения, но можно сделать так же, как и в макете 2.
<br>
Подсказка: только не position: absolute, я вас умоляю. Свойство placeholder поможет.

<br>
<br>

Задание 3.
<br>
Теперь нужно сделать так, чтобы при наведении на лейбл поля формы оно подсвечивалось (кроме селекта), а при клике на лейбл поля формы само поле бралось в фокус. Как оно должно выглядеть можно посмотреть на макете 3.
<br>
Подсказка: никаких обработчиков onClick и hover эффектов здесь самому писать не нужно (name).

<br>
<br>

Задание 4.
<br>
Нужно пометить 3 поля как обязательные: Логин, Пароль, Повторите пароль. Внешне обязательные поля должны выглядеть, как на макете 4.
<br>
Подсказка: никаких звёздочек самому вставлять и красить не нужно (required).

<br>
<br>

Задание 5.
<br>
Время поработать с данными, которые заполнил пользователь. Нужно сделать так, чтобы при нажатии на кнопку "Регистрация", а так же при нажатии на клавишу Enter на клавиатуре при фокусе на любом поле, в консоль выводилось всё, что заполнил пользователь в следующем формате:
<br>
<br>
{
<br>
&nbsp;&nbsp;&nbsp;&nbsp;login: "логин пользователя",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;password: "пароль пользователя",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;passwordRepeat: "пароль пользователя",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;email: "email пользователя",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;phoneNumber: "номер телефона пользователя",
<br>
&nbsp;&nbsp;&nbsp;&nbsp;country: "страна пользователя"
<br>
}
<br>
<br>
При этом значение полей, которые пользователь не заполнил должны быть равны null. Особое внимание уделите ситуации, когда пользователь ввёл что-то, а потом полностью стёр (в качестве значения такого поля должен остаться null, а не пустая строка). Пример можете увидеть на макете 5.
<br>
Подсказка: htmlType, Form.useForm, onFinish, initialValues, form.

<br>
<br>

Задание 6.
<br>
Наша кнопка "Очистить" до сих пор ничего не делает. Время это исправить. Нужно, чтобы она сбрасывала значения всех полей в форме. При этом нужно, чтобы после сброса значения всех полей были равны initialValues. На макете 6 можно найти пример данных после сброса формы.
<br>
Подсказка: не нужно пытаться установить значения полей вручную (resetFields).

<br>
<br>

Задание 7.
<br>
Добавим немного валидации для вязкости. У нас есть 3 обязательных поля: Логин, Пароль и Повторите пароль. Но при нажатии на кнопку "Регистрация" пользователю не подсвечивается, что он не заполнил какое-то обязательное поле. Да и было бы неплохо во время работы с формой, если пользователь удалит значение обязательного поля, вывести ему ошибку. А при нажатии на кнопку "Очистить" и, если пользователь всё заполнит правильно, ошибки должны пропасть. Как должна выглядеть ошибка можете посмотреть на макете 7.
<br>
Подсказка: не надо пытаться вкорячить ошибку вёрсткой (особенно с position: absolute) (rules, message, required).

<br>
<br>

Задание 8.
<br>
Наша форма становится похожа на нормальную, но валидация пока что оставляет желать лучшего. Начнём это исправлять с самого простого поля - Логин. Нам нужно добавить ограничение на длину логина. Пусть она будет не меньше 3 и не больше 1024 символов. При этом для разных ситуаций пользователю должны выводиться разные ошибки валидации, причём для данного поля только одна за раз. Пример можете найти на макете 8.
<br>
Подсказка: rules, message, required, validator

<br>
<br>

Задание 9.
<br>
Теперь добавим валидацию на поля Пароль и Повторите пароль. Очевидно, что она должна быть одинаковой. Правила валидации для пароля следующие:

1. Пароль должен быть обязателен
2. Длина пароля должна быть не менее 9 символов
3. Длина пароля должна быть не более 20 символов
4. Пароль должен содержать хотя бы одну цифру
5. Пароль должен содержать хотя бы одну прописную латинскую букву
6. Пароль должен содержать хотя бы одну строчную латинскую букву
7. Пароль должен содержать хотя бы один спецсимвол. К таким символам относятся следующие:
   .,!"№;%:?\*()\_+@#$^&- ="'/|\\{}`~<>[]

Для каждого из этих правил должна быть отдельная ошибка. Ошибки могут выводиться по несколько штук сразу. Если пользователь ввёл что-то в поле пароля, а затем удалил, то нужно показывать только ошибку, связанную с обязательностью пароля. Примеры можете посмотреть в макете 9.
<br>
Подсказка: ничего нового, кроме регулярных выражений, использовать не придётся.

<br>
<br>

Задание 10.
<br>
Добавим валидацию на оставшиеся два поля: email и номер телефона. Для номера телефона валидация будет упрощённая:

1. Длина номера телефона должна быть не менее 7 символов
2. Длина номера делефона должна быть не более 18 символов
3. Номер телефона может состоять только из цифр 0-9 и следующих символов: +- ()

Для валидации email используем страшное регулярное выражение с вот этого сайта: https://uibakery.io/regex-library/email (RFC 5322 compliant regex). В случае ошибки будем просто выводить сообщение "Вы ввели некорректный email". Как оно должно выглядеть можете посмотреть на макете 10.
<br>
Подсказка: учтите, что поля email и Номер телефона не обязательны, а значит, что если пользователь ничего не заполнил, то никаких ошибок ему выводить не нужно.

<br>
<br>

Задание 11.
<br>
Оно будет сложнее предыдущих. Представим ситуацию, что в связи с санкциями и внешней политикой наш сервис теперь по закону может обслуживать клиентов только из определённого ряда стран. Перечень разрешённых стран можно загрузить из какого-нибудь правительственного сайта (например, с госуслуг или какого-нибудь https://санкции.ru). Наш backend раз в определённое время (например, раз в сутки) запрашивает этот список стран с правительственного сайта и можно считать, что на нём он всегда актуален. Следовательно, на нашей форме регистрации в списке стран так же должны быть только разрешённые законом (а то нас прикроют). Поэтому нам необходимо сделать подгрузку списка стран с нашего backend'а. А значит настало время заняться иммитацией загрузки данных. Естественно, загрузку данных нужно производить через отдельный хук. Назовите его как-нибудь типа useRequestMock или ещё как-нибудь. Внутри этого хука (И ТОЛЬКО ВНУТРИ НЕГО) можно использовать useEffect и useState для иммитации загрузки данных (этих двух хуков будет достаточно). Пусть хук возвращает список стран спустя 2 секунды (представим, что наш backend не очень быстрый). Пока идёт загрузка вместо стрелочки раскрытия опций селекта должен крутиться спиннер. Если пользователь попытается раскрыть селект до окончания загрузки данных, то в меню вместо опций должен крутиться спиннер. Запрос за данными не всегда может завершиться успешно (например, из-за проблем с сетью на стороне пользователя), а значит, что наш backend иногда может присылать ошибку. Если backend прислал ошибку, то в меню вместо опций селекта должна выводиться ошибка. Иммитировать ошибку можно при помощи Math.random() внутри хука или же просто захардкодив её в возвращаемых данных - как удобно, так и делайте. Как всё это должно выглядеть можно посмотреть на макете 11.
<br>
Подсказка: loading, dropdownRender, setTimeout, компонент Spin, иконка CloseCircleOutlined

<br>
<br>

Задание 12.
<br>
При регистрации довольно часто пользователю предлагают подписаться на рассылку всяких уведомлений на почту. Нам тоже нужно добавить такой чекбокс. Его значение в данных формы должна появиться под ключом subscribeToNewsletter. Подробнее можно посмотреть на макете 12.
<br>
Подсказка: компонент Checkbox, valuePropName

<br>
<br>

Задание 13.
<br>
Давайте теперь сэмитируем реальную отправку данных формы на бэк. Сделать это можно так же при помощи хука, иммитирующего запрос (скорее всего вам придётся сделать его lazy версию). При нажатии на кнопку "Регистрация" должен отправиться запрос, который должен идти хотя бы 2 секунды. Во время этого запроса вся форма должна быть задизейблена (все инпуты, чекбоксы, селекты, кнопки, лейблы и т.д.), а в кнопке регистрации рядом с текстом "Регистрация" должен крутиться спиннер. Если пользователь успешно зарегистрировался (пришёл положительный ответ с бэка), то выводим нотификашку об успешной регистрации. Если с бэка пришла ошибка, то выводим нотификашку с ошибкой, которая пришла с бэка. В любом случае после получения ответа с бэка форма раздизейбливается и спиннеры убираются. Как всё это должно выглядеть можно посмотреть на макете 13.
<br>
Подсказка: не надо вешать disable на каждый отдельный Form.Item. disabled, notification, useNotification.

<br>
<br>

Задание 14.
<br>
Вам не кажется, что мы упустили одну важную деталь при валидации паролей? Да, в правилах валидации полей "Пароль" и "Повторите пароль" нужно добавить ещё одно правило: введённые пароли должны совпадать. Ошибка должна начать появляться только если и в поле "Пароль" и в поле "Повторите пароль" хотя бы что-то введено, но значения не совпадают. При несовпадении паролей ошибка должна появляться сразу на двух полях и не пропадать до тех пор, пока пароли не совпадут. Как должна выглядеть эта ошибка можно увидеть на макете 14.
<br>
Подсказка: rules - это массив не только объектов, validateFields, onChange.

<br>
<br>

Задание 15.
<br>
Снова сложное задание. В логике работы нашей формы регистрации осталось всего пару изъянов (помимо слабой валидации номеров телефонов). У нас есть поле "Повторите пароль". Какой смысл держать это поле разблокированным, если пользователь ещё ничего не ввёл в поле "Пароль"? Тот же самый вопрос касается и чекбокса "Получать уведомления на почту": если пользователь не ввёл email, то нет смысла давать ему возможность чекнуть этот чекбокс. В своих рассуждениях мы можем пойти ещё дальше: нет смысла разблокировать эти поля до тех пор, пока пользователь не ввёл именно валидное значение в связанные с ними. Вот это нам и предстоит реализовать. На макете 15 можете посмотреть как оно должно выглядеть. При отправке данных на бэк нужно учитывать, что пользователь мог ввести валидное значение, например, в поле email, чекнуть чекбокс, а потом стереть то, что он ввёл в email. В таком случае нам, очевидно, нужно отправить на бэк false (чекбокс должен анчекнуться, если у email стал невалиден). Для этого задания в компонентах для полей "Повторите пароль" и "Получать уведомления на почту" можно использовать useEffect и useState (но только для этих двух полей и больше ни для каких других). Помните, что ошибки валидации должны появляться только тогда, когда пользователь начал что-то вводить.
<br>
Подсказка: dependencies + noStyle / useWatch, validateFields.

<br>
<br>

Задание 16.
<br>
Нам нет особого смысла показывать ошибки валидации на задизейбленном поле. Поэтому, если они у вас показываются на поле "Повторите пароль" пока оно задизейблено, то самое время из скрыть. Но как только поле раздизейблится, то должна сработать валидация.
<br>
Подсказка: rules, validateFields.
